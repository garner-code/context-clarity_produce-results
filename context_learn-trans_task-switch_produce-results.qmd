---
title: "context_learn-trans_task-switch_produce-results"
format: html
    code-fold: TRUE
    default-image-extension: svg
editor: visual
---

## Produce the results for Contextual clarity during training hinders learning transfer but spares task switching

This notebook provides a computationally reproducible record of the analysis and figure generation for the paper 'Contextual clarity during training hinders learning transfer but spares task switching'.

## Settings and other things

This notebook assumes you have the following file structure. Note that the pre-existing csv files were generated by the code in [this repository.](https://github.com/garner-code/doors)

``` markdown
top_folder/
│   ├── _quarto.yml
│   ├── *.Rproj
│   ├── this-qmd-doc.qmd
│   ├── R/
│   │   └── all-r-scripts.R
│   ├── data-wrangled/
│   │   └── exp_[exp_str]_evt.csv
│   │   └── exp_[exp_str]_avg.csv
│   │   └── exp_lt_maggi-k4.csv
│   ├── figs/
│   ├── res/
```

First, load required packages and set the relative paths for data and other required things...

```{r, fold=TRUE, results='hide'}
options(tidyverse.quiet = TRUE)
library(tidyverse)
library(grid)
library(gridExtra)
library(knitr)
library(magick)
library(ggpubr)
library(vioplot)
library(rstatix)
library(emmeans)
library(afex)
library(pdftools)
library(purrr)
library(GGally)

data_path = 'data-wrangled/' # for all data derivs
fig_path = 'figs/' # for figures
res_path = 'res/' # for inferential results

function_loc <- "R" # where are the functions?
req_functions <- list.files(function_loc)
sapply(req_functions, function(x) source(paste(here::here(function_loc),
                                               x, sep="/")))

# # now some font settings
library(extrafont)
#font_import() # run this once only, comment out after first time
loadfonts(device='pdf')

## now some variables that will help us run code across both experiments
exp_strs <- c('lt','ts')
j_wdth <- 10 # this is for the task jumps fig
j_hgt <- j_wdth*(6/10)
trn_bp_wdth = j_wdth*.8 # this is for the knowledge onset plot
trn_bp_hgt = j_hgt

```

## Experiment One

### How did training impact task jumps?

This is where we look at the task-jumps measure between the two groups. Here I create a group x trial type dataframe and draw and save the boxplots. Note I will collect the data for both experiments here, but I will present them separately.

```{r, results='hide'}

# first, get the task jump data - note that I am not saving it as a csv,
# as it already exists with all the relevant info in the _avg csv
get_jump_data <- function(exp_str, data_path){
  
  tmp <- read.csv(paste(data_path, 'exp_', exp_str,
                        '_avg.csv', sep='')) %>%
    filter(ses == 2) %>%
    select(sub, train_type, context, switch, context_changes) %>%
    group_by(sub, train_type, switch) %>% 
    summarise(jumps=mean(context_changes)) %>%
    ungroup()
  tmp$exp = exp_str
  tmp
}

jumps <- do.call(rbind, lapply(exp_strs, get_jump_data,
                               data_path = data_path))

col_scheme = c('#7570b3', '#e7298a')

gen_jumps_plot(jumps,
               'jumps ~ switch*train_type', 
               exp_strs,
               col_scheme,
               j_wdth, j_hgt,
               paste(fig_path, 'task-jumps', sep=''),
               fig_labs = c('A', 'B'),
               ylabel = 'Jumps',
               xlabel = 'Group',
               ylims=c(0,5))

```

Now lets see the fig in all its glory -

![Fig 5: People in the frequent switch group broke up their routines to jump tasks](figs/task-jumps_4tlks.svg){fig-align="cent"}

Now lets apply the ANOVA model to the data -

```{r, results='hide'}

# first set the factors to be factors
jumps$sub <- as.factor(jumps$sub)
jumps$train_type <- as.factor(jumps$train_type)
levels(jumps$train_type) <- c('stable','variable')
jumps$switch <- as.factor(jumps$switch)
levels(jumps$switch) <- c('stay','switch')

# now run the ANOVA model
# set emmeans option to multivariate
afex_options(emmeans_model = "multivariate")
# perform the statistical model
exp_strs <- unique(jumps$exp)
tj_aovs <- lapply(exp_strs, function(x) 
  aov_ez("sub", "jumps", jumps %>% filter(exp == x), 
         within = "switch",
         between = "train_type"))
names(tj_aovs) <- exp_strs

# convert the anovas to a dataframe, save the results and show as a table
convert_aov_to_df <- function(aovl, exp_str){
  ref = aovl$anova_table
  tibble(exp = rep(exp_str, length(ref$F)),
         effect = rownames(ref),
         numDF = ref$`num Df`,
         denDF = ref$`den Df`,
         Fstat = ref$F,
         ges = ref$ges,
         p = ref$`Pr(>F)`)
}
tj_aov_dat <- do.call(rbind, 
                      lapply(1:length(exp_strs),
                             function(x) convert_aov_to_df(tj_aovs[[x]],
                                                           exp_strs[x])))
# do some manual rounding of columns
tj_aov_dat$Fstat <- round(tj_aov_dat$Fstat, 2)
tj_aov_dat$ges <- round(tj_aov_dat$ges, 3)
tj_aov_dat$p <- round(tj_aov_dat$p, 3)

# now an id column for referencing in overleaf
tj_aov_dat$id <- paste(tj_aov_dat$exp, tj_aov_dat$effect, sep="_") 
write.csv(tj_aov_dat, paste(res_path, 'task_jumps_aov.csv', sep=""), row.names=FALSE)

```

We can see from the above results that we have a significant group x switch interaction for both experiments. We need to follow this up with post-hoc contrasts.

First, lets define the contrasts that we will apply to task jumps and general errors across both experiments -

```{r}

train_ph_win <- list("stable_sw_v_st" = c(-1, 0, 1, 0), # switch > stay for stable group
                     "variable_sw_v_st" = c(0, -1, 0, 1))
train_ph_btwn <- list("grp_stay" = c(-1, 1, 0, 0), # var > stab
                      "grp_switch" = c(0, 0, -1, 1))

```

Now apply them to Experiment 1 task jumps, and write the output as a csv file

```{r}

tj_emm_int_lt <- emmeans(tj_aovs[["lt"]], c("train_type", "switch"))
tj_contrasts_win_lt <- contrast(tj_emm_int_lt, train_ph_win, adjust="scheffe")
tj_contrasts_btwn_lt <- contrast(tj_emm_int_lt, train_ph_btwn, adjust="scheffe")
tj_contrasts_lt <- summary(rbind(tj_contrasts_win_lt, tj_contrasts_btwn_lt))
tj_contrasts_lt$estimate <- round(tj_contrasts_lt$estimate, 2)
tj_contrasts_lt$SE <- round(tj_contrasts_lt$SE, 2)
tj_contrasts_lt$p.value <- round(tj_contrasts_lt$p.value, 2)
tj_contrasts_lt$Fstat <- round(tj_contrasts_lt$t.ratio^2, 2)

write.csv(tj_contrasts_lt, paste(res_path, 'task_jumps_post_hoc_lt.csv', sep=""), row.names=FALSE)
```

Now save the table of estimated marginal means for reporting

```{r}

tj_emm_int_lt <- summary(tj_emm_int_lt)
tj_emm_int_lt$emmean <- round(tj_emm_int_lt$emmean,2)
tj_emm_int_lt$SE <- round(tj_emm_int_lt$SE,2)
tj_emm_int_lt$id <- paste(tj_emm_int_lt$train_type, tj_emm_int_lt$switch, sep="_")
write.csv(tj_emm_int_lt, paste(res_path, 'task_jumps_emms_lt.csv', sep=""), row.names=FALSE)
```

### How did training affect general errors?

Now we apply the same analysis as above, but to the general errors -

```{r}

# get general errors data
get_error_data <- function(exp_str, data_path){
  
  tmp <- read.csv(paste(data_path, 'exp_', exp_str,
                        '_avg.csv', sep='')) %>%
    filter(ses == 2) %>%
    select(sub, train_type, context, switch, general_errors) %>%
    group_by(sub, train_type, switch) %>% 
    summarise(errors=mean(general_errors)) %>%
    ungroup()
  tmp$exp = exp_str
  tmp
}

errors <- do.call(rbind, lapply(exp_strs, get_error_data,
                                data_path = data_path))

gen_jumps_plot(errors,
               'errors ~ switch*train_type',
               exp_strs,
               col_scheme,
               j_wdth, j_hgt,
               paste(fig_path, 'general-errors', sep=''),
               fig_labs = c('C', 'D'),
               ylabel = 'Errors',
               ylims=c(0,1),
               xlabel = 'Group')

```

![Fig 5: People in the two groups showed the same levels of out of task errors](figs/general-errors_4tlks.svg){fig-align="cent"}

Next, I will put the task jumps and error figures together, for the paper.

```{r}

fnms = c(paste(fig_path, 'task-jumps', sep=''), 
         paste(fig_path, 'general-errors', sep=''))

ims = lapply(fnms, function(x) image_read_pdf(paste(x, '.pdf', sep='')))

multi <- c(ims[[1]]) %>%
         image_append() %>%
        c(ims[[2]]) %>%
         image_append(stack=TRUE)
plt_hgt = j_hgt*2 # get the height of the traj plot
plt_wdth = j_wdth
pdf(paste(fig_path, 'jumps-and-errors.pdf', sep=''), width=plt_wdth,
    height=plt_hgt)
plot(multi)
dev.off()
```

```{r, results='hide'}

# first set the factors to be factors
errors$sub <- as.factor(errors$sub)
errors$train_type <- as.factor(errors$train_type)
levels(errors$train_type) <- c('stable','variable')
errors$switch <- as.factor(errors$switch)
levels(errors$switch) <- c('stay','switch')

# perform the statistical model
exp_strs <- unique(errors$exp)
er_aovs <- lapply(exp_strs, function(x) 
  aov_ez("sub", "errors", errors %>% filter(exp == x), 
         within = "switch",
         between = "train_type"))
names(er_aovs) <- exp_strs

er_aov_dat <- do.call(rbind, 
                      lapply(1:length(exp_strs),
                             function(x) convert_aov_to_df(er_aovs[[x]],
                                                           exp_strs[x])))

cols2round <- c("Fstat", "ges", "p")
er_aov_dat[,cols2round] <- apply(er_aov_dat[,cols2round], 2, round, 2)
er_aov_dat$id <- paste(er_aov_dat$exp, er_aov_dat$effect, sep="_")

write.csv(er_aov_dat, paste(res_path, 'gen-errs_aov.csv', sep=""), row.names=FALSE)

```

```{r}

#| label: effect of group and switch on general errors
#| tbl-cap: "effect of group and switch on general errors"
kable(er_aov_dat, digits=2)
```

We have a statistically significant main effect of switch. So let's get the emmeans for that.

```{r}

# get emms for the main effect
ge_emm_sw_lt <- summary(emmeans(er_aovs[["lt"]], c("switch")))
# round the key variables to 2 dp
vars2round <- c("emmean", "SE")
ge_emm_sw_lt[,vars2round] <- apply(ge_emm_sw_lt[,vars2round], 2, round, 2)
# save
write.csv(ge_emm_sw_lt, paste(res_path, 'ge_emms_mesw_lt.csv', sep=""), row.names=FALSE)

# but also the numbers for the interaction, because its still useful info
ge_emm_sw_int_lt <- summary(emmeans(er_aovs[["lt"]], c("train_type","switch")))
# round
ge_emm_sw_int_lt[,vars2round] <- apply(ge_emm_sw_int_lt[,vars2round], 2, round, 2)
# make an id column
ge_emm_sw_int_lt$id <- paste(ge_emm_sw_int_lt$train_type, 
                             ge_emm_sw_int_lt$switch, sep="_")

# save
write.csv(ge_emm_sw_int_lt, paste(res_path, 'ge_emms_int_lt.csv', sep=""), row.names=FALSE)

```

### The impact of training on learning transfer

First steps are to wrangle the routine and group x transfer task data, and looking at learning onset for each group and task as a boxplot.

```{r}

###### nopw sort this code
# wrangle data
onset_dat <- read.csv(paste(data_path, 'exp_lt_maggi-k4.csv', sep='')) %>% 
  select(sid, ses, transfer, k4_onset) %>% 
  filter(ses == 3) %>%
  mutate(transfer=recode(transfer, `1` = 'comp', `2` = 'part')) 
names(onset_dat)[names(onset_dat) == "sid"] = "sub"

# now I get the group info
grp_inf <- read.csv(paste(data_path, 'exp_lt_avg.csv', sep='')) %>% 
  filter(ses == 3) %>%
  select(sub, train_type) %>%
  unique()
onset_dat <- inner_join(onset_dat, grp_inf, by='sub') %>%
                mutate(train_type=recode(train_type, `1`= 'stable', 
                                         `2` = 'variable'))
rm(grp_inf)

# some participants never learned, so we lose anyone who has a k4 of NaN,
# as that means their score was Inf
# remove participants for whom we couldn't determine learned
non_learn <- onset_dat %>% filter(is.infinite(k4_onset)) %>% 
                select(sub, train_type) %>% distinct()
onset_dat <- onset_dat %>% na.omit() %>%
                filter(is.finite(k4_onset))

# need to show that the probability of being excluded did not relate to group membership
non_learn_prob <- binom.test(sum(non_learn$train_type == "stable"), length(non_learn$train_type), 0.5)
non_learn_prob <- tibble(n_stable = non_learn_prob$statistic,
                         n_var = non_learn_prob$parameter - non_learn_prob$statistic,
                         total = n_stable + n_var,
                         n_total = 100 - total,
                         p = round(non_learn_prob$p.value, 2),
                         id = "val")
write.csv(non_learn_prob, paste(res_path, 'non_learn_grp_mem.csv', sep=""), row.names=FALSE)
# Now I have the data, I want to replace any outliers with NA and save the resulting data file
dvs <- c('k4_onset')
onset_dat <- cbind(onset_dat,
         do.call(cbind, lapply(dvs, remove_outliers, betas=onset_dat)))
k4_on_prct_out_removed <- tibble(prct = round(sum(is.na(onset_dat$k4_onset_flt)) / length(onset_dat$k4_onset), 2),
                                 val = 'prct')
write.csv(k4_on_prct_out_removed, paste(res_path, 'k4on_prct_rem.csv', sep=""), row.names=FALSE)

write.csv(onset_dat, paste(data_path, 'exp_lt_onset_cln.csv', sep=''), row.names=FALSE)
```

Now plot the learning onset scores -

```{r}

# first, I rename the k4 onset variable so I can plot it
onset_dat <- onset_dat %>% rename(k4_on = k4_onset_flt)

# also remove subs with NA
subs_w_na <- unique(onset_dat$sub[is.na(onset_dat$k4_on)])
onset_dat <- onset_dat %>% filter(!sub %in% subs_w_na)
# now remove subs who don't have 2 observations each 
onset_dat <- inner_join(onset_dat, 
                        onset_dat %>% group_by(sub) %>% summarise(N=length(sub))) %>%
  filter(N == 2)

col_scheme = c('#ccba72ff', '#4c5454ff')


k4_by_grp_fname = paste(fig_path,'k4_by_grp', sep='')
plt_tran_bp_4paper_andtlks(k4_by_grp_fname,
                trn_bp_wdth,
                trn_bp_hgt,
                onset_dat,
                'k4_on ~ transfer*train_type', 
                col_scheme,
                'Onset',
                c(0, 200),
                fig_lab = 'A')
```

Now I have the data in order I am ready to perform the analysis on the onset data as defined for task jumps above, but this time on learning transfer performance.

```{r}

# first set the factors to be factors
onset_dat$sub <- as.factor(onset_dat$sub)
onset_dat$train_type <- as.factor(onset_dat$train_type)
levels(onset_dat$train_type) <- c('stable','variable')
onset_dat$transfer <- as.factor(onset_dat$transfer)

onset_aov <- 
  aov_ez("sub", "k4_on", onset_dat, 
         within = "transfer",
         between = "train_type")

lt_onset_aov_dat <- convert_aov_to_df(onset_aov, "onset")
# do some manual rounding of columns
lt_onset_aov_dat$Fstat <- round(lt_onset_aov_dat$Fstat, 2)
lt_onset_aov_dat$ges <- round(lt_onset_aov_dat$ges, 3)
lt_onset_aov_dat$p <- round(lt_onset_aov_dat$p, 3)

# now save
write.csv(lt_onset_aov_dat, paste(res_path, 'lt_onset_aov.csv', sep=""), row.names=FALSE)


```

There are significant main effects of condition, so lets get the estimated marginal means -

write.csv(lt_onset_emm, paste(res_path, 'lt_onset_emm_transfer.csv', sep=""), row.names=FALSE)

```{r}

# get emms for the main effect
lt_onset_emm <- summary(emmeans(onset_aov, c("transfer")))
write.csv(lt_onset_emm, paste(res_path, 'lt_onset_emm_transfer.csv', sep=""), row.names=FALSE)

```

There is a significant group x condition interaction, so lets follow up -

```{r}

lt_onset_int_emm <- emmeans(onset_aov, c("train_type", "transfer"))

# copy the contrasts used for the task jump analysis and rename for current purposes
# You can use these across all measures
lt_ph_win_contrasts <- train_ph_win
lt_ph_win_contrasts$stable_comp_vs_mix <- lt_ph_win_contrasts$stable_sw_v_st
lt_ph_win_contrasts$variable_comp_vs_mix <- lt_ph_win_contrasts$variable_sw_v_st
lt_ph_win_contrasts$stable_sw_v_st <- NULL
lt_ph_win_contrasts$variable_sw_v_st <- NULL

lt_ph_btwn_contrasts <- train_ph_btwn
lt_ph_btwn_contrasts$grp_comp <- lt_ph_btwn_contrasts$grp_stay
lt_ph_btwn_contrasts$grp_mix <- lt_ph_btwn_contrasts$grp_switch
lt_ph_btwn_contrasts$grp_stay <- lt_ph_btwn_contrasts$grp_switch <- NULL
################################################################################

lt_onset_win <- contrast(lt_onset_int_emm, lt_ph_win_contrasts, adjust="scheffe")
lt_onset_btwn <- contrast(lt_onset_int_emm, lt_ph_btwn_contrasts, adjust="scheffe")
lt_onset_contrasts <- summary(rbind(lt_onset_win, lt_onset_btwn))

lt_onset_contrasts$estimate <- round(lt_onset_contrasts$estimate, 2)
lt_onset_contrasts$SE <- round(lt_onset_contrasts$SE, 2)
lt_onset_contrasts$p.value <- round(lt_onset_contrasts$p.value, 2)
lt_onset_contrasts$Fstat <- round(lt_onset_contrasts$t.ratio^2, 2)

write.csv(lt_onset_contrasts, paste(res_path, 'lt_onset_int_ph.csv', sep=""), row.names=FALSE)

```

There is also a main effect of group, so get the estimated marginal means for that -

```{r}

# get emms for the main effect
lt_onset_grp_emm <- summary(emmeans(onset_aov, c("train_type")))
write.csv(lt_onset_grp_emm, paste(res_path, 'lt_onset_emm_grp.csv', sep=""), row.names=FALSE)
```
